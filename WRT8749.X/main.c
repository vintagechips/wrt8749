/*
    Intel 8748/8749 Programmer Firmware

    Target: WRT8749 - EMUZ80 add-on board
    CPU: PIC18F47Q43
    Compiler: MPLAB XC8 v2.50
    Written by Tetsuya Suzuki
*/

// CONFIG1
#pragma config FEXTOSC = OFF    // External Oscillator Selection (Oscillator not enabled)
#pragma config RSTOSC = HFINTOSC_64MHZ// Reset Oscillator Selection (HFINTOSC with HFFRQ = 64 MHz and CDIV = 1:1)

// CONFIG2
#pragma config CLKOUTEN = OFF   // Clock out Enable bit (CLKOUT function is disabled)
#pragma config PR1WAY = ON      // PRLOCKED One-Way Set Enable bit (PRLOCKED bit can be cleared and set only once)
#pragma config CSWEN = ON       // Clock Switch Enable bit (Writing to NOSC and NDIV is allowed)
#pragma config FCMEN = ON       // Fail-Safe Clock Monitor Enable bit (Fail-Safe Clock Monitor enabled)

// CONFIG3
#pragma config MCLRE = EXTMCLR  // MCLR Enable bit (If LVP = 0, MCLR pin is MCLR; If LVP = 1, RE3 pin function is MCLR )
#pragma config PWRTS = PWRT_OFF // Power-up timer selection bits (PWRT is disabled)
#pragma config MVECEN = ON      // Multi-vector enable bit (Multi-vector enabled, Vector table used for interrupts)
#pragma config IVT1WAY = ON     // IVTLOCK bit One-way set enable bit (IVTLOCKED bit can be cleared and set only once)
#pragma config LPBOREN = OFF    // Low Power BOR Enable bit (Low-Power BOR disabled)
#pragma config BOREN = SBORDIS  // Brown-out Reset Enable bits (Brown-out Reset enabled , SBOREN bit is ignored)

// CONFIG4
#pragma config BORV = VBOR_1P9  // Brown-out Reset Voltage Selection bits (Brown-out Reset Voltage (VBOR) set to 1.9V)
#pragma config ZCD = OFF        // ZCD Disable bit (ZCD module is disabled. ZCD can be enabled by setting the ZCDSEN bit of ZCDCON)
#pragma config PPS1WAY = OFF    // PPSLOCK bit One-Way Set Enable bit (PPSLOCKED bit can be set and cleared repeatedly (subject to the unlock sequence))
#pragma config STVREN = ON      // Stack Full/Underflow Reset Enable bit (Stack full/underflow will cause Reset)
#pragma config LVP = ON         // Low Voltage Programming Enable bit (Low voltage programming enabled. MCLR/VPP pin function is MCLR. MCLRE configuration bit is ignored)
#pragma config XINST = OFF      // Extended Instruction Set Enable bit (Extended Instruction Set and Indexed Addressing Mode disabled)

// CONFIG5
#pragma config WDTCPS = WDTCPS_31// WDT Period selection bits (Divider ratio 1:65536; software control of WDTPS)
#pragma config WDTE = OFF       // WDT operating mode (WDT Disabled; SWDTEN is ignored)

// CONFIG6
#pragma config WDTCWS = WDTCWS_7// WDT Window Select bits (window always open (100%); software control; keyed access not required)
#pragma config WDTCCS = SC      // WDT input clock selector (Software Control)

// CONFIG7
#pragma config BBSIZE = BBSIZE_512// Boot Block Size selection bits (Boot Block size is 512 words)
#pragma config BBEN = OFF       // Boot Block enable bit (Boot block disabled)
#pragma config SAFEN = OFF      // Storage Area Flash enable bit (SAF disabled)
#pragma config DEBUG = OFF      // Background Debugger (Background Debugger disabled)

// CONFIG8
#pragma config WRTB = OFF       // Boot Block Write Protection bit (Boot Block not Write protected)
#pragma config WRTC = OFF       // Configuration Register Write Protection bit (Configuration registers not Write protected)
#pragma config WRTD = OFF       // Data EEPROM Write Protection bit (Data EEPROM not Write protected)
#pragma config WRTSAF = OFF     // SAF Write protection bit (SAF not Write Protected)
#pragma config WRTAPP = OFF     // Application Block write protection bit (Application Block not write protected)

// CONFIG10
#pragma config CP = OFF         // PFM and Data EEPROM Code Protection bit (PFM and Data EEPROM code protection disabled)

// #pragma config statements should precede project file includes.
// Use project enums instead of #define for ON and OFF.

#include <xc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define _XTAL_FREQ 64000000UL // System clock
#define BUF_SIZE 0x0800 // 2K bytes
#define TCY(n) __delay_us(4*n)
#define newline() printf("\r\n") // MS style new line
#define crline() printf("\r") // MS style cr line
#define clrscrn() printf("\033[2J\033[H") // Clear screen
#define hex_byte(b) scanf("%2hhx", &b) // Read HEX byte
#define hex_word(w) scanf("%4x", &w) // Read HEX word

// Pin asign
inline void u3t_setup() { // RA6 setup for UART3 Transmitter
    ANSELA6 = 0; // Disable analog function
    LATA6 = 1; // Default level
    TRISA6 = 0; // TX set as output
    RA6PPS = 0x26;  //RA6->UART3:TX3;
}
inline void u3r_setup() { // RA7 setup for UART3 Receiver
    ANSELA7 = 0; // Disable analog function
    TRISA7 = 1; // RX set as input
    U3RXPPS = 0x07; //RA7->UART3:RX3;
}
inline void ledw_setup() { // RB0 setup for LED WRITE
    ANSELB0 = 0; // Disable analog function
    LATB0 = 0; // Turn off
    TRISB0 = 0; // Set as output
}
#define led_write(s) {LATB0 = s;} // LED WRITE
inline void ledm_setup() { // RB1 setup for LED MOUNT
    ANSELB1 = 0; // Disable analog function
    LATB1 = 0; // Turn off
    TRISB1 = 0; // Set as output
}
#define led_mount(s) {LATB1 = s;} // LED MOUNT
#define ismount() LATB1
inline void res_setup() { // RB2 setup for Reset
    ANSELB2 = 0; // Disable analog function
    LATB2 = 1; // Inactive
    TRISB2 = 0; // Set as output
}
#define res_latch(s) {LATB2 = s;} // 8749 0->1 address latch
inline void xtal1_setup() { // RB3 setup for XTAL1
    ANSELB3 = 0; // Disable analog function
    TRISB3 = 0; // Set as output
    RB3PPS = 0x1A;  //RB3->PWM2_16BIT:PWM21;
}
inline void xtal2_setup() { // RB4 setup for XTAL2
    ANSELB4 = 0; // Disable analog function
    TRISB4 = 0; // Set as output
    RB4PPS = 0x1B;  //RB4->PWM2_16BIT:PWM22;
}
inline void t0_setup() { // RB5 setup for T0
    ANSELB5 = 0; // Disable analog function
    LATB5 = 1; // Not latch
    TRISB5 = 0; // Set as output
}
#define t0_mode(s) {LATB5 = s;} // 8749 0:program 1:verify
inline void adrsh_setup() { // RC0-3 setup for Address upper
    ANSELC = 0; // Disable analog function
    LATC = 0; // Turn off
    TRISC = 0; // Set as output
}
#define adrs_h(a) {LATC = (LATC & 0xf0) | (a & 0x0f);}
inline void ea_setup() { // RC4 setup for EA switch
    ANSELC4 = 0; // Disable analog function
    LATC4 = 0; // Turn off
    TRISC4 = 0; // Set as output
}
#define ea_eprom(s) {LATC4 = s;} // 8749 0:normal 1:eprom
inline void prog_setup() { // RC5 setup for PROG switch
    ANSELC5 = 0; // Disable analog function
    LATC5 = 0; // Turn off
    TRISC5 = 0; // Set as output
}
#define prog_pulse(s) {LATC5 = s;} // 8749 0->1->0 writing pulse
inline void vdd_setup() { // RC6 setup for VDD switch
    ANSELC6 = 0; // Disable analog function
    LATC6 = 0; // Turn off
    TRISC6 = 0; // Set as output
}
#define vdd_power(s) {LATC6 = s; led_write(s);} // 8749 0:off 1:on
inline void t1t_setup() { // RC7 setup for Timer1 trig
    ANSELC7 = 0; // Disable analog function
    WPUC7 = 1; // Weak pull-up enabled
    TRISC7 = 1; // Set as input
    T1CKIPPS = 0x17; // Timer1 clock in: RC7
}
inline void adrsl_setup() { // RD0-7 Address lower / Data
    ANSELD = 0; // Disable analog function
    LATD = 0; // Turn off
    TRISD = 0xff; // default input
}
#define adrs_l(a) {LATD = a;} // Out address high

// Code buffer
unsigned char buf[BUF_SIZE]; // Code buffer
extern unsigned char demo[]; // See bottom of this file

// Address / Data bus
union {
    unsigned int w; //16 bits Address
    struct {
        unsigned char l; //Address low
        unsigned char h; //Address high
    };
} ad;

// Task message
const char *taskL = "Load HEX from terminal to buffer";
const char *taskC = "Copy built-in DEMO to buffer";
const char *taskR = "Read code from 8748/8749 and store it in buffer";
const char *taskD = "Dump buffer";
const char *taskW = "Write code in buffer to 8748/8749";
const char *taskV = "Voltage adjustment check";

// Never called, logically
void __interrupt(irq(default),base(8)) Default_ISR(){}

// Called 10 times per second by a Timer2
void __interrupt(irq(TMR2),base(8)) Timer2_ISR() {
    TMR2IF = 0; // clear the TMR2 interrupt flag
    TMR1GIF = 0; // Clear gate interrupt flags

    TMR1ON = 0; // Timer1 stop
    if((TMR1 < 20000) && TMR1IF == 0) // < 3MHz/15/10, Not overflow
        led_mount(0)
    else
        led_mount(1)
        
    TMR1 = 0; // Timer1 clear
    TMR1IF = 0; // Clear interrupt flags
    TMR1ON = 1; // Timer1 Start
}

// Initial states
void stat_initial(){
    vdd_power(0); // Normal power
    res_latch(0); // Unlatch
    t0_mode(1); // Normal(Verify) mode
    ea_eprom(0); // Normal mode
    prog_pulse(0); // PROG pull-down ground
    TRISD = 0xff; // BUS floating
}

// wait for 50ms (50000 counts)
inline void wait50ms(){
    TMR0IF = 0; // clear interrupt flag
    TMR0H = 0x3c; // 15536 >> 8
    TMR0L = 0xb0; // 15536 & 0xff;
    T0EN = 1; // Start
    while (TMR0IF == 0); // Wait for overflow
    T0EN = 0; // Stop
}

// UART3 Transmit
void putch(char c) {
    while(!U3TXIF); // Wait or Tx interrupt flag set
    U3TXB = c; // Write data
}

// UART3 Recive
int getch(void) {
    while(!U3RXIF); // Wait for Rx interrupt flag set
    return U3RXB; // Read data
}

// Get answer
int getans(const char *s){
    int c;
    do {
        c = getch();
        if(isalpha(c))
            c &= 0x5f;
    } while(strchr(s, c) == NULL);
    putch((char)c); newline();
    newline();
    return c;
}

// Check code size
void chk_size(){
    unsigned int code_size;

    code_size = BUF_SIZE;
    while(--code_size)
        if(buf[code_size])
            break;
    if(buf[0])
        code_size++;

    printf("Code size: %04X", code_size); newline();
}

// Check mount
void chk_mount(){
    if(ismount())
        return;

    printf("Mount device in ZIF socket"); newline();
    while(!ismount()); // Wait for mount
    __delay_ms(500); // Wait until completely locked
    printf("Good job"); newline();
    newline();
}

// Load command
void com_load(){
	unsigned char len, type, sum, data, extd;
    
    for (ad.w = 0; ad.w < BUF_SIZE; ad.w++)
        buf[ad.w] = 0;
    extd = 0;
    printf("%s", taskL); newline();
    printf("Ready"); newline();
    
    do {
        while(getch() != ':');
        hex_byte(len);
        hex_word(ad.w);
        hex_byte(type);

        if(type != 0)
            extd = 1;
        
        while(len--){
            hex_byte(data);
            if((extd != 1) && (ad.w < BUF_SIZE))
                buf[ad.w++] = data;
        }
        hex_byte(sum); // not care
        putch('.');
    } while((type != 1) || ((len == 0) && (ad.w == 0)));
    newline();

    chk_size();
    printf("Load complete"); newline();    
    newline();
}

// Dump command
void com_dump() {
    unsigned int col, row, start, stop;
    int c;
    
    printf("%s", taskD); newline();

    start = 0;
    while(1) {
        printf("ADRS: ");
        for(col = 0; col < 16; col++)
           printf("+%X ", col);
        printf("ASCII"); newline();
        
        stop = start + 16;
        for (row = start; row < stop; row++) {
            printf("%04X: ", row * 16);
            for (col = 0; col < 16; col++) {
                printf("%02X", buf[row * 16 + col]);
                putch(col == 15 ? ' ' : ',');
            }
            for (col = 0; col < 16; col++) {
                c = buf[row * 16 + col];
                putch(isprint(c)? (char)c : '.');
            }
            newline();
        }

        if(stop >= 128){
            printf("[E] Exit : "); 
            c = getans("E");
        } else {
            printf("[N] Next page, [E] Exit : "); 
            c = getans("NE");
        }
        if(c == 'E')
            return;
        
        start = stop;
    }
}

// Write command
inline void com_write(){
    unsigned char data;
    int c, device;

    printf("%s", taskW); newline();
    stat_initial(); //Initial states
    chk_mount();
    printf("[8] 8748, [9] 8749 : ");
    c = getans("89");
    device = c - 0x37; // 8->1, 9->2
    
    t0_mode(0); // 3)Program mode
    TCY(4);
    ea_eprom(1); // 4)Active program mode
    
    for (ad.w = 0; ad.w < 16 * device; ad.w++)
        putch('_');
    printf("100%%"); crline();

    for (ad.w = 0; ad.w < 0x400 * device; ad.w++){
        if((ad.w % 64) == 0) // Progress bar
            putch('.');
        if(buf[ad.w] == 0) // Skip 0
            continue;
        
        // 5)Address and Data setup
        TRISD = 0; // BUS output
        adrs_l(ad.l); // Address lower
        adrs_h(ad.h); // Address high
        TCY(4);
        res_latch(1); // 6)Address latch
        TCY(4);

        // Program
        LATD = buf[ad.w]; // 7)Data applied
        TCY(4);
        vdd_power(1); // 8)Programming power
        prog_pulse(1); // 9)Write pulse
        wait50ms();
        prog_pulse(0);
        vdd_power(0); // 10)Programming power off
        TCY(4);

        // Verify
        TRISD = 0xff; // BUS input
        t0_mode(1); // 11)Verify mode
        TCY(4);
        data = PORTD; // 12)Data read
        if(buf[ad.w] != data){
            newline();
            printf("Verify error"); newline();
            printf("Address %04X. Write %02X, Read %02X", ad.w, buf[ad.w], data); newline();
            printf("Write uncomplete"); newline();
            goto write_exit;
        } 
    	t0_mode(0); // 13)Program mode
        res_latch(0); // 14)Address unlatch
    }
    newline();
    printf("Write complete"); newline();

write_exit:    
    stat_initial(); //Initial states
    newline();
}

// Read command
inline void com_read(){
    printf("%s", taskR); newline();
    chk_mount();

    stat_initial(); //Initial states
//    t0_mode(0); // Program mode
    TCY(4);
    ea_eprom(1); // Active program mode
    
    for (ad.w = 0; ad.w < BUF_SIZE; ad.w++){
        // Address and Data setup
        TRISD = 0; // BUS output
        adrs_l(ad.l); // Address low
        adrs_h(ad.h); // Address high
        TCY(4);
        res_latch(1); // Address latch
        TCY(4);

        TRISD = 0xff; // BUS input
//        t0_mode(1); // Verify mode
        TCY(4);
        buf[ad.w] = PORTD; // Data read
        res_latch(0); // Address unlatch
    }
    stat_initial(); //Initial states

    chk_size();
    printf("Read complete"); newline();
    printf("Code is stored in buffer"); newline();
    newline();
}

// Voltage adjustment check command
inline void com_vadj(){ // Check voltage adjustment
    int c;
    
    printf("%s", taskV); newline();
    if(ismount()){
        printf("Remove device from the ZIF socket"); newline();
        while(ismount());
        printf("Good job"); newline(); newline();
    }
    
    ea_eprom(1); // 8749 0:normal 1:eprom
    prog_pulse(1); // 8749 0->1->0 writing pulse
    vdd_power(1); // 8749 0:off 1:on
    
    printf("Programming voltage is output as follows"); newline();
    printf("EA(7)=18V, PROG(25)=18V, VDD(26)=21V"); newline();
    printf("[S] Switch to Initial voltage, [E] Exit : "); 
    c = getans("SE");

    ea_eprom(0); // 8749 0:normal 1:eprom
    prog_pulse(0); // 8749 0->1->0 writing pulse
    vdd_power(0); // 8749 0:off 1:on

    if(c == 'S'){
        printf("Initial voltage is output as follows"); newline();
        printf("EA(7)=5V, PROG(25)=0V, VDD(26)=5V"); newline();
        printf("To exit, press [E] : "); 
        getans("E");
    }
}

// Copy command
inline void com_copy(){
    printf("%s", taskC); newline();
    for (ad.w = 0; ad.w < BUF_SIZE; ad.w++)
        buf[ad.w] = demo[ad.w];

    chk_size();
    printf("Copy complete"); newline();
    printf("Code is stored in buffer"); newline();
    newline();
}

// main routine
void main(void) {
    // System initialize
    OSCFRQ = 0x08; // 64MHz internal OSC

    // Port initialize
    ledw_setup(); // RB0 setup for LED WRITE
    ledm_setup(); // RB1 setup for LED MOUNT
    res_setup(); // RB2 setup for Reset
    t0_setup(); // RB5 setup for T0
    adrsh_setup(); // RC0-3 setup for Address upper
    adrsl_setup(); // RD0-7 Address lower / Data
    ea_setup(); // RC4 setup for EA switch
    prog_setup(); // RC5 setup for PROG switch
    vdd_setup(); // RC6 setup for VDD switch

    // UART3 initialize
    u3t_setup(); // RA6 setup for UART3 Transmitter
    u3r_setup(); // RA7 setup for UART3 Receiver
    U3BRG = 416; // 9600bps @ 64MHz
    U3RXEN = 1; // Receiver enable
    U3TXEN = 1; // Transmitter enable
    U3ON = 1; // Serial port enable
    
    // PWM2 initialize
    xtal1_setup(); // RB3 setup for XTAL1
    xtal2_setup(); // RB4 setup for XTAL2
    PWM2CLK = 0x3; // Clock source HFINTOSC 64MHz
    PWM2PR = 17; // Period 64MHz/3.5MHz - 1
    PWM2CPRE = 0; // Clock Prescale 1
    PWM2S1CFG = 0x80; // P2 complemental
    PWM2S1P1 = 9; // P1 Duty
    PWM2S1P2 = 9; // P2 Duty
    PWM2PIF = 0; // Clear period interrupt flag
    PWM2IF = 0; // Clear interrupt flag
    PWM2GIRbits.S1P1IF = 0; // Clear P1 interrupt flag
    PWM2GIRbits.S1P2IF = 0; // Clear P2 interrupt flag
    PWM2CON = 0x80; // PWM2 Enable

    // Timer0 setup for 50ms pulse
    T0CON0 = 0x10; // 16bit mode
    T0CON1 = 0x44; // Fosc/4, Prescale 1/16

    // Timer1 setup for ALE count
    t1t_setup(); // RC7 setup for Timer1 trig
    T1GCON = 0; // Free run (Gate mode disable)
    T1RD16 = 1; // 16bit mode
    TMR1 = 0; // Timer1 clear
    TMR1IF = 0; // Clear interrupt flags
    TMR1ON = 1; // Start
    
    // Timer2 setup for time-base
    T2CLKCON = 6; // Clock source MFINTOSC (31.25kHz)
    T2CON = 0x40; // Prescale 1/16 (1953Hz)
    T2PR = 195; // Limit 195 count (10Hz)
    TMR2IF = 0; // Clearing IF flag
    TMR2IE = 1; // Enable interrupt
    T2ON = 1; // Timer2 start

    GIE = 1; // Global interrupt enable

    stat_initial(); //Initial states
    clrscrn(); // Clear screen
    printf("WRT8749 : Intel 8748/8749 programmer"); newline();

    while(1){
        int c;
        printf("[L] %s", taskL); newline();
        printf("[C] %s", taskC); newline();
        printf("[R] %s", taskR); newline();
        printf("[D] %s", taskD); newline();
        printf("[W] %s", taskW); newline();
        printf("[V] %s", taskV); newline();
        printf("Select task : "); 
        c = getans("LRCDWV");
        switch(c){
            case 'L': com_load(); break;
            case 'C': com_copy(); break;
            case 'R': com_read(); break;
            case 'D': com_dump(); break;
            case 'W': com_write(); break;
            case 'V': com_vadj(); break;
            default: 
                break;
        }
    }
}

// DEMO code
unsigned char demo[] = {
	0x24, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 0x24,
	0x55, 0xb8, 0x20, 0xb0, 0x00, 0xfa, 0x14, 0x14,
	0x60, 0xe6, 0x0d, 0x93, 0x37, 0x17, 0x93, 0xfa,
	0x61, 0xa1, 0xe6, 0x1e, 0xc9, 0x11, 0x93, 0xfa,
	0x14, 0x14, 0x61, 0xa1, 0xf6, 0x2a, 0xc9, 0xf1,
	0x07, 0xa1, 0x93, 0xfa, 0x61, 0x57, 0xa1, 0xe6,
	0x37, 0xc9, 0x23, 0x01, 0x61, 0x57, 0xa1, 0x93,
	0xfa, 0x14, 0x14, 0x03, 0x9a, 0x61, 0x57, 0xa1,
	0xf6, 0x48, 0xc9, 0x23, 0x99, 0x61, 0x57, 0xa1,
	0x93, 0xb8, 0x25, 0xb9, 0x21, 0xbf, 0x04, 0xfe,
	0xad, 0xfd, 0x67, 0xad, 0xe6, 0x58, 0xf0, 0xa1,
	0x18, 0x19, 0xef, 0x51, 0x93, 0xb8, 0x21, 0xb9,
	0x29, 0xba, 0x24, 0xbb, 0x77, 0xbf, 0x04, 0x14,
	0x72, 0x53, 0x0f, 0x6a, 0xe3, 0xa0, 0x18, 0xef,
	0x67, 0x93, 0xff, 0x53, 0x01, 0x6b, 0xb3, 0x79,
	0x7c, 0xf1, 0x47, 0x93, 0xf1, 0x19, 0x93, 0xb8,
	0x2b, 0xb9, 0x29, 0xbb, 0xd9, 0xbe, 0x00, 0xbf,
	0x04, 0xfe, 0x77, 0xae, 0x14, 0x72, 0x53, 0x0f,
	0xc6, 0x96, 0xfe, 0x43, 0x08, 0xae, 0xef, 0x89,
	0xb8, 0x25, 0xb9, 0x29, 0xba, 0x04, 0xbb, 0x77,
	0x14, 0x65, 0x14, 0x49, 0xba, 0x04, 0x14, 0x09,
	0xbf, 0x04, 0xb9, 0x21, 0xfe, 0xad, 0xfd, 0x67,
	0xad, 0xe6, 0xb5, 0xb1, 0xff, 0x19, 0xef, 0xae,
	0xba, 0x08, 0x14, 0x09, 0xb8, 0x25, 0xb9, 0x2b,
	0xba, 0x14, 0xbb, 0x77, 0x14, 0x65, 0x14, 0x49,
	0xba, 0x04, 0x14, 0x09, 0xb8, 0x29, 0xb9, 0x2b,
	0xf1, 0xa0, 0x18, 0x19, 0xf1, 0xa0, 0x14, 0x5d,
	0x93, 0xdb, 0xe0, 0xf0, 0xd1, 0xaa, 0x47, 0x93,
	0xfa, 0x18, 0x19, 0x93, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9a, 0x0f, 0x65, 0x00, 0xd5, 0xb8, 0x20, 0xbf,
	0x00, 0xc5, 0x25, 0x55, 0xb9, 0x29, 0xb1, 0x87,
	0x19, 0xb1, 0x49, 0x14, 0x5d, 0xba, 0x2d, 0x14,
	0x09, 0xb9, 0x2b, 0xb1, 0x00, 0x19, 0xb1, 0x00,
	0x14, 0xcc, 0x14, 0x09, 0xb9, 0x2c, 0xba, 0x05,
	0x26, 0x38, 0xba, 0x01, 0x46, 0x40, 0x34, 0x48,
	0x14, 0x2b, 0x14, 0x7f, 0xba, 0x2d, 0x24, 0x22,
	0x14, 0x2b, 0x14, 0xcc, 0xba, 0x01, 0x24, 0x22,
	0x14, 0x38, 0x14, 0xcc, 0xba, 0x05, 0x24, 0x22,
	0xf1, 0x53, 0x01, 0xc6, 0x51, 0x23, 0x02, 0x8d,
	0x93, 0x23, 0x0d, 0x9d, 0x93, 0xd5, 0x23, 0x03,
	0x5f, 0xaf, 0x96, 0x5d, 0x10, 0xb9, 0x21, 0x69,
	0xa9, 0x9a, 0x0f, 0xf1, 0x39, 0xff, 0x03, 0x00,
	0xe3, 0x3a, 0x42, 0x03, 0xcc, 0x62, 0x1f, 0x93,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x80, 0x40, 0x20, 0x10, 0x8f, 0xbf, 0x4f, 0x2f,
	0x3f, 0x2f, 0x0f, 0xbf, 0x0f, 0x2f, 0x1f, 0x0f,
	0xcf, 0x0f, 0x4f, 0x5f, 0xe3, 0xf7, 0xe6, 0xe6,
	0xf2, 0xea, 0xea, 0xe7, 0xe2, 0xe2, 0xe2, 0xfa,
	0xeb, 0xfa, 0xea, 0xea, 0x12, 0xb7, 0x2a, 0x26,
	0x87, 0x46, 0x42, 0x37, 0x02, 0x06, 0x03, 0xc2,
	0x5a, 0xa2, 0x4a, 0x4b, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};